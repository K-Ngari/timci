---
title: "Database export - quality check "
author: "H. LANGET"
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M GMT%z')`"
---

```{r, include=FALSE}
knitr::opts_chunk$set(echo = FALSE,
                      warning = FALSE,
                      message = FALSE)
```

**Check description:** `r qc_description`

**Action:** `r qc_rule`

```{r}
cleaned_df <- NULL
n_detected <- 0
cleaned_df_status_update <- ""
```

```{r, eval=(qc_type=="nonvalid_deviceids")}
out <- timci::allocate_screening_facility2(df,
                                           research_facilities)
qc_df <- out[[1]]
cleaned_df <- out[[2]]
```

```{r, eval=(qc_type=="posterior_to_lockdate")}
qc_df <- df %>%
  dplyr::filter(date_visit > as.Date(lock_date, "%Y-%m-%d")) %>%
  dplyr::arrange(date_visit = as.Date(date_visit, "%Y-%m-%d")) # Order entries by date
cleaned_df <- df %>%
  dplyr::filter(date_visit <= as.Date(lock_date, "%Y-%m-%d")) %>%
  dplyr::arrange(date_visit = as.Date(date_visit, "%Y-%m-%d")) # Order entries by date
```

```{r, eval=(qc_type=="underaged_cg")}
qc_df <- df[df$cg_eligibility == 0, ]
cleaned_df <- df[df$cg_eligibility == 1, ]
```

```{r, eval=(qc_type=="ids_outside_lock_range")}
out <- timci::identify_ids_outside_lock_range(df = df,
                                              col_id = idcol,
                                              day0_df = day0_data,
                                              start_date = start_date,
                                              end_date = lock_date)
qc_df <- out[[1]]
```

```{r, eval=(qc_type=="nonvalid_ids_no_cleaning")}
out <- timci::identify_nonvalid_ids(df,
                                    idcol1,
                                    refdf,
                                    idcol2)
qc_df <- out[[1]]
```

```{r, eval=(qc_type=="nonvalid_ids")}
out <- timci::identify_nonvalid_ids(df,
                                    idcol1,
                                    refdf,
                                    idcol2)
qc_df <- out[[1]]
cleaned_df <- out[[2]]
```

```{r, eval=(qc_type=="date_discrepancy")}
out <- timci::detect_inconsistent_dates(df,
                                        col_date_start = col_date1,
                                        col_date_end = col_date2)
qc_df <- out[[1]]
cleaned_df <- out[[2]]
```


```{r, eval=(qc_type=="duplicates")}
out <- timci::identify_duplicates_by_dates(df,
                                           col_id,
                                           col_date,
                                           cleaning)
qc_df <- out[[1]]
cleaned_df <- out[[2]]
```

```{r, eval=(qc_type=="duplicates_check_pii")}
out <- timci::identify_repeat_duplicate(df,
                                        col_id,
                                        col_date,
                                        cleaning)
qc_df <- out[[1]]
cleaned_df <- out[[2]]
```

```{r, eval=(qc_type=="missing_clinical_presentation")}
qc_df <- timci::detect_missing_clinical_presentation(df)
outcols <- c("child_id", "fid", "date_visit", "uuid")
qc_df <- qc_df %>%
  dplyr::select(outcols) %>%
  dplyr::arrange(fid)
```

```{r, eval=(qc_type=="missing_diagnosis")}
qc_df <- timci::detect_missing_diagnosis(df)
outcols <- c("child_id", "fid", "date_visit", "uuid")
qc_df <- qc_df %>%
  dplyr::select(outcols) %>%
  dplyr::arrange(fid)
```

```{r, eval=(qc_type=="missing_referral")}
qc_df <- timci::detect_missing_referral(df)
outcols <- c("child_id", "fid", "date_visit", "uuid")
qc_df <- qc_df %>%
  dplyr::select(outcols) %>%
  dplyr::arrange(fid)
```

```{r, eval=!is.null(qc_df)}
n_detected <- nrow(qc_df)
```

**Check output:** The check has detected **`r n_detected`** record(s) with `r qc_text` in the `r db_name` database.

```{r}
qc_df_is_not_empty <- timci::is_not_empty(qc_df)
partial_disp <- FALSE
full_disp <- FALSE
if (qc_df_is_not_empty) {
  partial_disp <- qc_df_is_not_empty & ( nrow(qc_df) > 10 )
  full_disp <- qc_df_is_not_empty & ( nrow(qc_df) <= 10 )
}
```

```{r, eval=partial_disp, results='asis'}
qc_df %>%
  select(1:min(length(qc_df), 5)) %>%
  head(5) %>%
  knitr::kable(rowNames = FALSE,
               caption = "Five first rows")
```

```{r, eval=partial_disp, results='asis'}
cat("...")
```

```{r, eval=partial_disp, results='asis'}
qc_df %>%
  select(1:min(length(qc_df), 5)) %>%
  tail(5) %>%
  knitr::kable(rowNames = FALSE,
               caption = "Five last rows")
```

```{r, eval=full_disp, results='asis'}
qc_df %>%
  select(1:min(length(qc_df), 5)) %>%
  knitr::kable(rowNames = FALSE)
```

```{r, results = 'asis'}
timci::quality_check_export(df = qc_df,
                            idx = qc_idx,
                            label = qc_export_label,
                            cdir = qc_dir,
                            description = qc_export_description)
```

```{r, eval=!is.null(cleaned_df)}
cleaned_df_status_update <- paste0('After deletion of all the records detected by this check, there are now **', nrow(cleaned_df), '** record(s) in the ', db_name, ' database.')
```

`r cleaned_df_status_update`
