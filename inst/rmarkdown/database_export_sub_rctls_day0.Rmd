```{r}
write(timci::formats2h2("Review, process and export facility data"), stderr())
```

```{r}
write("Export Day 0 data and run corresponding quality checks", stderr())
```

## Day 0 data quality checks\n\n

```{r}
db_name <- "Day 0"
screening_data <- timci::extract_screening_data(facility_data)
out <- timci::extract_enrolled_participants(facility_data)
day0_data <- out[[1]]
pii <- out[[2]]
```

```{r}
n_raw_records <- nrow(facility_data)
n_day0 <- nrow(day0_data)
```

```{r}
day0_is_not_null <- !is.null(day0_data)
day0_is_not_empty <- timci::is_not_empty(day0_data)
```

Initially, there are **`r n_raw_records`** screening record(s) in the raw facility database from the start of the study on **`r start_date`**, including **`r n_day0`** record(s) corresponding to new Day 0 enrolments.

### Non-valid device IDs [context check]\n\n

**Rule:** records from devices different from the ones listed in the first section of this report are removed in the locked database. These *non-valid* devices were either used to collect training data or to collect data for another study than the one considered for this report.

```{r}
locked_screening_data <- timci::allocate_screening_facility(screening_data,
                                                            research_facilities)
```

```{r}
locked_day0_data <- timci::allocate_screening_facility(day0_data,
                                                       research_facilities)
locked_pii <- timci::allocate_screening_facility(pii,
                                                 research_facilities)
```


```{r}
n_locked_screening <- nrow(locked_screening_data)
n_nonvalid_deviceid_records <- n_raw_records - n_locked_screening
n_locked_day0 <- nrow(locked_day0_data)
```

```{r, results = 'asis'}
cat(paste0("**", n_nonvalid_deviceid_records, "** record(s) with non-valid device IDs detected and removed in the locked facility database, including **", n_day0 - n_locked_day0, "** Day 0 records."))
```

```{r}
# Replace Day 0 data by locked Day 0 data so that non-valid device IDs/facilities do not appear in the export
day0_data <- locked_day0_data
```

### Lock date [context check]\n\n

**Rule:** records entered after the lock date on **`r lock_date`** are removed in the locked database.

```{r}
locked_screening_data <- locked_screening_data %>%
  dplyr::filter(date_visit <= as.Date(lock_date, "%Y-%m-%d")) %>%
  dplyr::arrange(date_visit = as.Date(date_visit, "%Y-%m-%d")) # Order entries by date
locked_day0_data <- locked_day0_data %>%
  dplyr::filter(date_visit <= as.Date(lock_date, "%Y-%m-%d"))
locked_pii <- locked_pii %>%
  dplyr::filter(date_visit <= as.Date(lock_date, "%Y-%m-%d"))
```

```{r}
n_after_lockdate_records <- n_locked_screening - nrow(locked_screening_data)
```

```{r, results = 'asis'}
cat(paste0("**", n_after_lockdate_records, "** record(s) with an entry date posterior to the lock date on **", lock_date, "** detected and removed in the locked facility database, including **", n_locked_day0 - nrow(locked_day0_data), "** Day 0 record(s)."))
```

### Non-valid enrolling facility IDs [compliance check]\n\n

`r if (is_kenya) {'#### Initial check\n\n'}`

```{r, eval=(!is.null(locked_day0_data)&is_kenya), results='asis'}
qc_description <- ""
qc_rule <- "Records corresponding to facility IDs not listed in the first section of this report are detected and corrected proactively where possible."
qc_type <- "nonvalid_ids_no_cleaning"
df <- locked_day0_data
idcol1 <- "fid"
refdf <- research_facilities
idcol2 <- "facility_id"
qc_text <- "facility ID not valid"
qc_idx <- qc_nonvalid_fid1
qc_export_label <- "nonvalid_fids"
qc_export_description <- "the facility ID is not valid"
cat(knitr::knit_child('database_export_sub_quality_check.Rmd',
                      envir = environment(),
                      quiet = TRUE))
```

`r if (is_kenya) {'#### Facility ID manual edits\n\n'}`

```{r, results='asis', eval=is_kenya}
out <- timci::correct_day0_non_valid_facilities(locked_day0_data)
locked_day0_data <- out[[1]]
facility_edits <- out[[2]]
if (!is.null(facility_edits)) {
  facility_edits %>%
    select(old_child_id, uuid, new_child_id) %>%
    knitr::kable()
}
```

`r if (is_kenya) {'#### Second check after manual edits\n\n'}`

```{r, eval=!is.null(locked_day0_data), results='asis'}
qc_description <- ""
qc_rule <- "Records corresponding to facility IDs not listed in the first section of this report are removed in the locked database."
qc_type <- "nonvalid_ids"
df <- locked_day0_data
idcol1 <- "fid"
refdf <- research_facilities
idcol2 <- "facility_id"
qc_text <- "facility ID not valid"
qc_idx <- qc_nonvalid_fid2
qc_export_label <- "nonvalid_fids"
qc_export_description <- "the facility ID is not valid"
cat(knitr::knit_child('database_export_sub_quality_check.Rmd',
                      envir = environment(),
                      quiet = TRUE))
```

```{r, eval=!is.null(cleaned_df)}
locked_day0_data <- cleaned_df
```

`r if (is_india) {'### Inconsistent facility information [Context check]\n\n'}`

```{r, results='asis'}
if (Sys.getenv('TIMCI_COUNTRY') == 'India') {
  cat("**Rule**: records with inconsistent facility information are kept in the locked database, but will need to be checked more carefully (e.g: GPS data).\n\n")
}
```

```{r}
qc_inconsistent_facility <- NULL
if (Sys.getenv('TIMCI_COUNTRY') == 'India') {
  if (!is.null(locked_day0_data)) {
    if (nrow(locked_day0_data) > 0) {
      qc_inconsistent_facility <- locked_day0_data[locked_day0_data$fid != locked_day0_data$fid_ra, ]
      qc_inconsistent_facility <- qc_inconsistent_facility[c("child_id", "fid", "fid_ra", "uuid")]
    }
  }
}
```

```{r, results='asis'}
if (!is.null(qc_inconsistent_facility)) {
  if (nrow(qc_inconsistent_facility) > 0) {
    cat(paste0("**", nrow(qc_inconsistent_facility), "** record(s) with inconsistent facility information detected."))
  }
}
```

```{r, results='asis'}
if (!is.null(qc_inconsistent_facility)) {
  if (nrow(qc_inconsistent_facility) > 0) {
    qc_inconsistent_facility %>%
      knitr::kable(row.names = FALSE)
  }
}
```

### Non-valid enrolment [compliance check]\n\n

#### Caregiver eligibility [compliance check `r qc_underaged_cg_id`]\n\n

```{r, eval=!is.null(locked_day0_data), results='asis'}
qc_description <- "Caregivers must be above 18 years old to be able provide consent for the child to be part in the study."
qc_rule <- "Children with a caregiver below 18 years old are removed from the database."
qc_type <- "underaged_cg"
df <- locked_day0_data
qc_text <- "a consenting caregiver below 18 years old"
qc_idx <- qc_underaged_cg_id
qc_export_label <- "underaged_cg"
qc_export_description <- "the consenting caregiver is below 18 years old"
cat(knitr::knit_child('database_export_sub_quality_check.Rmd',
                      envir = environment(),
                      quiet = TRUE))
```

```{r, eval=!is.null(cleaned_df)}
locked_day0_data <- cleaned_df
```

### Submission timeliness [compliance checks]\n\n

#### Non-timely completion [compliance check `r qc_nontimely_completion_id`]\n\n

```{r}
qc_completion_ab1day <- NULL
```

```{r, eval=!is.null(facility_data)}
if (nrow(locked_day0_data) > 0) {
  qc <- timci::detect_non_timely_completion(locked_day0_data)
  qc_completion_ab1day <- qc[qc$diff > 0,]
}
```

**Definition:** Finalisation of the submission not done on the same day the submission was started (i.e., duration from start to end strictly superior to 0 day)

```{r, results='asis', eval=!is.null(qc_completion_ab1day)}
cat(paste0("**", nrow(qc_completion_ab1day), "** participant(s) for whom the submission was not finalised on the same day it was started."))
```

```{r, results='asis', eval=!is.null(qc_completion_ab1day)}
timci::quality_check_export(qc_completion_ab1day,
                            qc_nontimely_completion_id,
                            "nontimely_day0_completion",
                            qc_dir,
                            "the submission was not finalised on the same day it was started")
```

```{r, results='asis', eval=!is.null(qc_completion_ab1day)}
if (nrow(qc_completion_ab1day) > 0) {
  hist(as.numeric(qc_completion_ab1day$diff),
       breaks = c(1:max(as.numeric(qc_completion_ab1day$diff), na.rm = TRUE)),
       xlab="Days between submission start and finalisation" ,
       ylab="Occurences",
       main="")
}
```

#### Non-timely submission [compliance check `r qc_nontimely_submission_id`]\n\n

**Definition:** transfer of a finalised submission to the ODK Central server not done on the day the submission was finalised (i.e. transfer time superior to 0 day). A delay superior to 12 days mean that the participant has never appeared in the Day 7 follow-up log on the tablet.

```{r}
qc_transfer_ab1day <- NULL
qc_transfer_ab7days <- NULL
qc_transfer_ab12days <- NULL

if (!is.null(facility_data)) {
  if (nrow(locked_day0_data) > 0) {
    qc_transfer <- detect_non_timely_submission(locked_day0_data)
    qc_transfer_ab1day <- qc_transfer[qc_transfer$diff > 0,]
    qc_transfer_ab7days <- qc_transfer[qc_transfer$diff > 6,]
    qc_transfer_ab12days <- qc_transfer[qc_transfer$diff > 11,]
  }
}
```

```{r, results='asis'}
if (!is.null(qc_transfer_ab1day)) {
  if (nrow(qc_transfer_ab1day) > 0) {
    cat(paste0("**", nrow(qc_transfer_ab1day), "** participant(s) for whom the submission was not transferred on the same day it was finalised."))
  }
}
```

```{r, results='asis'}
if (!is.null(qc_transfer_ab7days)) {
  if (nrow(qc_transfer_ab7days) > 0) {
    cat(paste0("**", nrow(qc_transfer_ab7days), "** participant(s) for whom the submission was transferred after 7 days and more."))
  }
}
```

```{r, results='asis'}
if (!is.null(qc_transfer_ab7days)) {
  if (nrow(qc_transfer_ab7days) > 0) {
    qc_transfer_ab7days %>%
      knitr::kable(row.names = FALSE)
  }
}
```

```{r, results='asis'}
if (!is.null(qc_transfer_ab12days)) {
  if (nrow(qc_transfer_ab12days) > 0) {
    cat(paste0("**", nrow(qc_transfer_ab12days), "** participants for which the submission was transferred after 12 days and more (participant never displayed in the Day 7 follow-up log on the tablet)."))
  }
}
```

```{r, results='asis'}
if (!is.null(qc_transfer_ab12days)) {
  if (nrow(qc_transfer_ab12days) > 0) {
    qc_transfer_ab12days %>%
      knitr::kable(row.names = FALSE)
  }
}
```

```{r, results='asis', eval=!is.null(qc_transfer_ab1day)}
timci::quality_check_export(qc_transfer_ab1day,
                            qc_nontimely_submission_id,
                            "nontimely_day0_submission",
                            qc_dir,
                            "the submission was not transferred on the same day it was finalised")
```

```{r, results='asis', eval=!is.null(qc_transfer_ab1day)}
if (nrow(qc_transfer_ab1day) > 0) {
  hist(as.numeric(qc_transfer_ab1day$diff),
       breaks = c(1:max(as.numeric(qc_transfer_ab1day$diff), na.rm = TRUE)),
       xlab="Days between submission start and finalisation" ,
       ylab="Occurences",
       main="")
}
```

### Duplicate management\n\n

#### Child ID duplicates [compliance check] 

`r if ( is_tanzania | is_kenya ) { paste0('##### Initial check ', qc_duplicate_id1, '\n\n') }`

```{r, eval=!is.null(locked_day0_data)&(is_tanzania|is_kenya), results='asis'}
qc_description <- "To be updated later"
qc_rule <- "child ID duplicates are detected and corrected proactively were possible."
qc_type <- "duplicates"
df <- locked_day0_data
col_id <- "child_id"
col_date <- "start"
qc_text <- "duplicated IDs"
qc_idx <- qc_duplicate_id1
qc_export_label <- "timci_day0_data_id_duplicates"
qc_export_description <- "the submission was allocated the same ID that has been used for another participant in the databse"
cat(knitr::knit_child('database_export_sub_quality_check.Rmd',
                      envir = environment(),
                      quiet = TRUE))
```

`r if ( is_tanzania ) { '##### Test data removed\n\n' }`

To be completed

`r if ( is_tanzania ) { '##### Child ID repeat visit manual correction\n\n' }`

To be completed

`r if ( is_tanzania | is_kenya ) { '##### Child ID duplicate manual edits\n\n' }`

```{r, results='asis'}
out <- timci::correct_day0_child_ids(locked_day0_data)
locked_day0_data <- out[[1]]
duplicate_edits <- out[[2]]
if (!is.null(duplicate_edits)) {
  duplicate_edits %>%
    select(old_child_id, uuid, new_child_id) %>%
    knitr::kable()
}
```

`r if ( is_tanzania | is_kenya ) { paste0('##### Second check after manual edits', qc_duplicate_id2, '\n\n') }`

```{r, eval=!is.null(locked_day0_data)&(is_tanzania|is_kenya), results='asis'}
qc_description <- "To be updated later"
qc_rule <- "Remaining child ID duplicates are removed in the locked database."
qc_type <- "duplicates"
df <- locked_day0_data
col_id <- "child_id"
col_date <- "start"
qc_text <- "duplicated IDs"
qc_idx <- qc_duplicate_id2
qc_export_label <- "timci_day0_data_id_duplicates"
qc_export_description <- "the submission was allocated the same ID that has been used for another participant in the databse"
cat(knitr::knit_child('database_export_sub_quality_check.Rmd',
                      envir = environment(),
                      quiet = TRUE))
```

```{r, eval=!is.null(cleaned_df)}
locked_day0_data <- cleaned_df
```

### Possible multiple enrolments\n\n

```{r child_duplicate-subsection, child = 'database_export_sub_QC_child_multiple_enrolments.Rmd'}
```

### Withdrawal management\n\n

```{r, child = if(day0_is_not_empty) 'database_export_sub_rctls_withdrawals.Rmd'}
```

### Clinical presentation [Mandatory check `r qc_missing_cp_id`]\n\n

```{r, results='asis', eval=!is.null(locked_day0_data)}
qc_description <- "All participants should have complete information about their clinical presentation, i.e. a participant cannot have simultaneously:

* No convulsions (sx_convulsions = 0)
* No lethargy (sx_lethargy = 0)
* No vomiting (sx_vomit = 0 or sx_vomit = 98)
* No feeding less than usual (sx_less_feed = 0)
* No cough (sx_cough = 0)
* No difficulty breathing (sx_difficulty_breath = 0)
* No diarrhoea (sx_diarrhoea = 0)
* No fever (sx_fever = 0)
* No other complaint (sx_var = 96)"
qc_rule <- "No modification of the database, only reporting."
qc_type <- "missing_clinical_presentation"
df <- locked_day0_data
qc_text <- "missing clinical presentation"
qc_idx <- qc_missing_cp_id
qc_export_label <- "missing_clinical_presentation"
qc_export_description <- "the clinical presentation is missing"
cat(knitr::knit_child('database_export_sub_quality_check.Rmd',
                      envir = environment(),
                      quiet = TRUE))
```

### Diagnosis [Mandatory check]\n\n

**Description:** all participants should have complete information about their diagnosis for their Day 0 visit.

Check not implemented yet.

### Management [Mandatory check]\n\n

**Description:** all participants should have complete information about their management for their Day 0 visit.

Check not implemented yet.

### Data cleaning summary\n\n

```{r, results = 'asis'}
timci::format_nrow("There are", locked_day0_data, "records in the locked Day 0 database.")
```

```{r}
timci::create_day0_qc_flowchart(n_raw_records,
                                n_nonvalid_deviceid_records,
                                n_after_lockdate_records,
                                n_locked_screening,
                                'NA',
                                'NA',
                                'NA',
                                'NA')
```

### Data export\n\n

```{r export-facility-audit, results = 'asis'}
timci::dataset_export(facility_data_audit,
                      "00",
                      "timci_facility_audit_data",
                      rctls_dir,
                      "Facility audit data")
```

```{r export-screening-data, results = 'asis'}
timci::dataset_export(screening_data,
                      "01",
                      "timci_screening_data",
                      rctls_dir,
                      "Raw screening data")
```

```{r export-locked-screening-data, results = 'asis'}
timci::dataset_export(locked_screening_data,
                      "01",
                      "timci_screening_data",
                      locked_db_dir,
                      "Cleaned screening data")
```

```{r, eval=(!is.null(facility_data) & deidentification_on)}
deidentified_day0_data <- timci::deidentify_data(day0_data)
locked_day0_data <- timci::deidentify_data(locked_day0_data)
```

```{r, eval=!deidentification_on, results = 'asis'}
timci::dataset_export(day0_data,
                      "02",
                      "timci_day0_data",
                      rctls_dir,
                      "Raw Day 0 data")
```

```{r, eval=deidentification_on, results = 'asis'}
timci::dataset_export(deidentified_day0_data,
                      "02",
                      "timci_day0_data",
                      rctls_dir,
                      "Deidentified raw Day 0 data")
```

```{r, results = 'asis'}
timci::dataset_export(locked_day0_data,
                      "02",
                      "timci_day0_data",
                      locked_db_dir,
                      "Cleaned Day 0 data")
```

```{r split-pii-from-research-data, eval=!is.null(facility_data)}
ts <- timci::export_df2xlsx(pii,
                            tempdir(),
                            "timci_contact_data")
pii_pwd <- Sys.getenv("TIMCI_PII_PW")
zip(params$participant_zip, 
    files = file.path(tempdir(), "timci_contact_data.xlsx"), 
    flags = paste("-r9Xj --password", pii_pwd))
```

```{r export-visit-data, results = 'asis', eval=!is.null(facility_data)}
study_data <- timci::extract_all_visits(facility_data)
```

```{r, eval=!deidentification_on, results = 'asis'}
timci::dataset_export(study_data,
                      "03",
                      "timci_facility_visits_data",
                      rctls_dir,
                      "Facility visit data")
```

```{r, eval=deidentification_on, results = 'asis'}
deidentified_facility_data <- timci::deidentify_data(study_data)
timci::dataset_export(deidentified_facility_data,
                      "03",
                      "timci_facility_visits_data",
                      rctls_dir,
                      "Facility visit data")
```
